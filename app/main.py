import io
import json
import os

import pandas as pd

from config.logger import logger

INPUT_RAW_PATH = "./data/input/raw/cves"
INPUT_RAW_CSV_PATH = "./data/input/processed/cves_raw.csv"
INPUT_CLEAN_CSV_PATH = "./data/input/processed/cves_clean.csv"
CLEAN_CSV_WITH_MALWARE_TYPE_PATH = "./data/input/processed/cves_with_malware_type.csv"


def __get_property_from_list(data, property_names=None, target_key=None):
    """
    Recursively search for a key within specific properties of a JSON-like dictionary or list.
    If the key is found in a list of objects, return the first occurrence in each object.

    :param data: The JSON-like dictionary or list.
    :param property_names: List of properties to search within.
    :param target_key: The key to search for.
    :return: A list of values associated with the key if found within the properties, else None.
    """
    if not property_names:
        # If no more properties to check, look directly for the target_key
        return __get_property(data, target_key)

    property_name = property_names[0]

    if isinstance(data, dict):
        if property_name in data:
            sub_data = data[property_name]
            if isinstance(sub_data, (dict, list)):
                # Recurse with remaining properties
                return __get_property_from_list(sub_data, property_names[1:], target_key)

    elif isinstance(data, list):
        results = []
        for item in data:
            if isinstance(item, dict) and property_name in item:
                sub_data = item[property_name]
                if isinstance(sub_data, (dict, list)):
                    # Collect results from each item in the list
                    result = __get_property_from_list(sub_data, property_names[1:], target_key)
                    if result is not None:
                        results.extend(result)
        return results[0] if len(results) else None

    # If the key is not found
    return None


def __get_property(data, target_key):
    if isinstance(data, dict):
        if target_key in data:
            return data[target_key]
        for key, value in data.items():
            result = __get_property(value, target_key)
            if result is not None:
                return result
    elif isinstance(data, list):
        for item in data:
            result = __get_property(item, target_key)
            if result is not None:
                return result


def __get_property_text(data, property_names=None, target_key=None):
    value = __get_property_from_list(data, property_names, target_key)

    if value:
        value_clean = (
            value.replace("\t", " ")
            .replace("\n", " ")
            .replace("\r", " ")
            .replace(",", " ")
            .replace(";", " ")
            .replace('"', " ")
        )
        return value_clean
    else:
        return ""


def __get_references(data):
    references = ""
    try:
        reference_data = data["containers"]["cna"]["references"]
    except Exception as e:
        logger.error(f"Error getting references: {e}")
        return references

    if reference_data and len(reference_data) > 0:
        for reference in reference_data:
            references = references + reference["url"] + ","

    return references


def determine_malware_type(row):
    # Example logic based on 'cve_id', 'date_published', and 'description'
    # This logic can be customized based on your specific needs

    if pd.isna(row["description"]):
        return "unknown"
    description = row["description"].lower()
    if "ransomware" in description or "encrypts" in description:
        return "ransomware"
    elif "trojan" in description:
        return "trojan"
    elif "worm" in description:
        return "worm"
    elif "spyware" in description:
        return "spyware"
    elif "virus" in description:
        return "virus"
    elif "phishing" in description:
        return "phishing"
    elif "rootkit" in description:
        return "rootkit"
    elif "backdoor" in description:
        return "backdoor"
    elif "adware" in description:
        return "adware"
    else:
        return "unknown"


if __name__ == "__main__":
    logger.info(f"Service started {os.getcwd()}")

    # TODO borrar csv
    for root, dirs, files in os.walk(INPUT_RAW_PATH):
        for file in files:
            if file.endswith(".json"):
                json_file_path = os.path.join(root, file)
                try:
                    with open(json_file_path, "r", encoding="utf-8") as f:
                        data = json.load(f)
                        # TODO product y vendor no son correctos
                        cve = {
                            "cve_id": __get_property_from_list(data, target_key="cveId"),
                            "date_published": __get_property_from_list(
                                data, target_key="datePublished"
                            ),
                            "capec_id": __get_property_from_list(data, target_key="capecId"),
                            "affected_product": __get_property_text(
                                data, ["containers", "cna"], "product"
                            ),
                            "affected_vendor": __get_property_text(
                                data, ["containers", "cna"], "vendor"
                            ),
                            "description": __get_property_text(
                                data, ["containers", "cna", "descriptions"], "value"
                            ),
                            "references": __get_references(data),
                        }

                        df = pd.DataFrame(cve, index=[0])
                        file_exists = os.path.isfile(INPUT_RAW_CSV_PATH)

                        # Append DataFrame to CSV with or without headers based on file existence
                        df.to_csv(
                            INPUT_RAW_CSV_PATH, mode="a", index=False, header=not file_exists
                        )
                    print(f"Successfully processed {json_file_path}")
                except Exception as e:
                    print(f"Error processing {json_file_path}: {e}")

    print(f"Generated {INPUT_RAW_CSV_PATH} file: all JSON files have been processed")

    # Keep track of problematic lines
    problematic_lines = []

    with open(INPUT_RAW_CSV_PATH, "r", encoding="utf-8") as file:
        for line_number, line in enumerate(file, start=1):
            try:
                # Attempt to parse each line as a CSV
                logger.info(line)
                df = pd.read_csv(io.StringIO(line))
            except pd.errors.ParserError:
                print(f"ParserError at line {line}")
                problematic_lines.append(line)
    print("Problematic lines:", problematic_lines)

    # Clean CSV
    df = pd.read_csv(INPUT_RAW_CSV_PATH)

    df.dropna(subset=["cve_id"], inplace=True)
    df.dropna(subset=["date_published"], inplace=True)
    df["affected_product"] = df["affected_product"].replace("n/a", None)
    df["affected_vendor"] = df["affected_vendor"].replace("n/a", None)
    df.drop_duplicates(subset=["cve_id", "date_published"], inplace=True)

    df.to_csv(INPUT_CLEAN_CSV_PATH, index=False)

    print(f"Generated {INPUT_CLEAN_CSV_PATH} file")

    # Determine malware type
    df = pd.read_csv(
        INPUT_CLEAN_CSV_PATH,
        encoding="utf-8",
    )

    df["malware_type"] = df.apply(determine_malware_type, axis=1)
    df.to_csv(CLEAN_CSV_WITH_MALWARE_TYPE_PATH, index=False)

    print(f"Generated {CLEAN_CSV_WITH_MALWARE_TYPE_PATH} file")
