import json
import os

from config.logger import logger
from src.model.cve_repository import CVERepository

INPUT_RAW_PATH = "./data/input/raw/cves"


class ReadInput:
    def __init__(self, output_repository: CVERepository):
        self._output_repository = output_repository

    def _get_property_from_list(self, data, property_names=None, target_key=None):
        if not property_names:
            return self._get_property(data, target_key)

        property_name = property_names[0]

        if isinstance(data, dict):
            if property_name in data:
                sub_data = data[property_name]
                if isinstance(sub_data, (dict, list)):
                    return self._get_property_from_list(sub_data, property_names[1:], target_key)

        elif isinstance(data, list):
            results = []
            for item in data:
                if isinstance(item, dict) and property_name in item:
                    sub_data = item[property_name]
                    if isinstance(sub_data, (dict, list)):
                        result = self._get_property_from_list(
                            sub_data, property_names[1:], target_key
                        )
                        if result is not None:
                            results.extend(result)
            return results[0] if len(results) else None
        return None

    def _get_property(self, data, target_key):
        if isinstance(data, dict):
            if target_key in data:
                return data[target_key]
            for key, value in data.items():
                result = self._get_property(value, target_key)
                if result is not None:
                    return result
        elif isinstance(data, list):
            for item in data:
                result = self._get_property(item, target_key)
                if result is not None:
                    return result

    def _get_property_text(self, data, property_names=None, target_key=None):
        value = self._get_property_from_list(data, property_names, target_key)

        if value:
            value_clean = (
                value.replace("\t", " ")
                .replace("\n", " ")
                .replace("\r", " ")
                .replace(",", " ")
                .replace(";", " ")
                .replace('"', " ")
            )
            return value_clean
        else:
            return ""

    def _get_references(self, data):
        references = ""
        try:
            reference_data = data["containers"]["cna"]["references"]
        except Exception:
            return references

        if reference_data and len(reference_data) > 0:
            for reference in reference_data:
                references = references + reference["url"] + ","

        return references

    def __call__(self):
        logger.info("Starting ReadInput use case...")
        for root, dirs, files in os.walk(INPUT_RAW_PATH):
            for file in files:
                if file.endswith(".json"):
                    json_file_path = os.path.join(root, file)
                    try:
                        with open(json_file_path, "r", encoding="utf-8") as f:
                            data = json.load(f)
                            cve = {
                                "cve_id": self._get_property_from_list(data, target_key="cveId"),
                                "date_published": self._get_property_from_list(
                                    data, target_key="datePublished"
                                ),
                                "description": self._get_property_text(
                                    data, ["containers", "cna", "descriptions"], "value"
                                ),
                                "references": self._get_references(data),
                            }
                            self._output_repository.save(cve)

                        logger.debug(f"Successfully processed {json_file_path}")
                    except Exception as e:
                        logger.error(f"Error processing {json_file_path}: {e}")

        logger.info("All input JSON files have been processed")
