import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error

from config.logger import logger
from src.model.cve_repository import CVERepository


class ForecastCVEsByMalwareType:
    def __init__(self, input_repository: CVERepository, output_repository: CVERepository):
        self._input_repository = input_repository
        self._output_repository = output_repository

    def __call__(self):
        logger.info("Starting ForecastCVEsByMalwareType use case...")
        cves = self._input_repository.find_all()
        df = pd.DataFrame(list(cves))

        df["malware_type_final"] = np.where(
            (df["malware_type_x"].isna()) | (df["malware_type_x"] == "unknown"),
            df["predicted_malware_type"],
            df["malware_type_x"],
        )

        # Group by date and malware_type to count occurrences
        grouped_df = (
            df.groupby([df["date_published"].dt.to_period("M"), "malware_type_final"])
            .size()
            .reset_index(name="count")
        )

        # Convert to timestamp for time series models
        grouped_df["date_published"] = grouped_df["date_published"].dt.to_timestamp()

        # visualize data
        # Set the plot style
        sns.set_style("whitegrid")

        # Generate and save a plot for each malware type
        for malware_type in grouped_df["malware_type_final"].unique():
            # Filter data for the current malware type
            df_malware = grouped_df[grouped_df["malware_type_final"] == malware_type]

            # Plot the number of CVEs over time for this malware type
            plt.figure(figsize=(14, 7))
            sns.lineplot(data=df_malware, x="date_published", y="count", hue="malware_type_final")
            plt.title(f"Number of CVEs for {malware_type} Over Time")
            plt.xlabel("Date Published")
            plt.ylabel("Count")
            plt.legend(title="Malware Type", bbox_to_anchor=(1.05, 1), loc="upper left")
            plt.xticks(rotation=45)
            plt.tight_layout()

            # Save the plot to an image file
            plt.savefig(
                f"./output/cve_by_{malware_type}.png", format="png", dpi=300, bbox_inches="tight"
            )

            # Optionally show the plot
            # plt.show()

            # Clear the figure to avoid overlapping plots in the next iteration
            plt.clf()

        # Create a list to store models and future dataframes
        models = {}
        future_dfs = {}
        forecast_dfs = {}

        # Iterate over each malware type
        for malware in grouped_df["malware_type_final"].unique():
            # Prepare the data for Prophet
            df_malware = grouped_df[grouped_df["malware_type_final"] == malware]

            if (
                df_malware.shape[0] < 2
                or df_malware["count"].isna().sum() >= df_malware.shape[0] - 1
            ):
                logger.warning(f"Not enough data for {malware}. Skipping this malware type.")
            else:

                df_prophet = df_malware.rename(columns={"date_published": "ds", "count": "y"})[
                    ["ds", "y"]
                ]

                # Initialize and fit the model
                model = Prophet(
                    yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False
                )
                model.fit(df_prophet)

                # Store the model
                models[malware] = model

                # Create a future dataframe for forecasting
                future = model.make_future_dataframe(
                    periods=12, freq="M"
                )  # Forecast for 12 months into the future
                future_dfs[malware] = future

                # Make predictions
                forecast = model.predict(future)
                forecast_dfs[malware] = forecast

                # Plot forecast
                fig, ax = plt.subplots(figsize=(10, 6))
                model.plot(forecast, ax=ax)
                ax.set_title(f"Forecast for {malware}")
                ax.set_xlabel("Date")
                ax.set_ylabel("Number of CVEs")

                # Add legend
                ax.legend(["Historical", "Forecast", "Uncertainty Interval"])

                # Save the plot as an image file
                plt.savefig(
                    f"./output/forecast_{malware}.png", format="png", dpi=300, bbox_inches="tight"
                )
                #   plt.show()

        # Evaluate each model
        for malware, forecast in forecast_dfs.items():
            # Filter the forecast to only include the actual dates
            actual = grouped_df[grouped_df["malware_type_final"] == malware]
            forecast_filtered = forecast.loc[forecast["ds"].isin(actual["date_published"])]

            # Calculate metrics
            mae = mean_absolute_error(actual["count"], forecast_filtered["yhat"])
            mse = mean_squared_error(actual["count"], forecast_filtered["yhat"])
            rmse = mse**0.5

            logger.info(f"{malware} - MAE: {mae:.2f}, MSE: {mse:.2f}, RMSE: {rmse:.2f}")

        # forecast and save to csv
        for malware, forecast in forecast_dfs.items():
            # Filter the forecast to only include the future dates
            future_forecast = forecast.loc[forecast["ds"] > grouped_df["date_published"].max()]

            # Save to CSV
            future_forecast.to_csv(f"./output/forecast_{malware}.csv", index=False)

            # data_dict = future_forecast.to_dict("records")
            # for cve in data_dict:
            #     self._output_repository.save(cve)

            logger.info(f"Forecast for {malware} saved to forecast_{malware}.csv")
