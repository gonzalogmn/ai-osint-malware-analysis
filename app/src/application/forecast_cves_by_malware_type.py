import csv
from datetime import datetime

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error

from config.logger import logger
from src.model.cve_repository import CVERepository


class ForecastCVEsByMalwareType:
    def __init__(self, input_repository: CVERepository, output_repository: CVERepository):
        self._input_repository = input_repository
        self._output_repository = output_repository

    def __call__(self):
        cves = self._input_repository.find_all()
        df = pd.DataFrame(list(cves))

        # TODO move to clean phase
        converted_dates = []
        for index, row in df.iterrows():
            date_published = row["date_published"]
            # Check if the input string contains 'T' and 'Z'
            if "T" in date_published and "Z" in date_published:
                if "." in date_published:
                    # Parse the ISO 8601 format with microseconds and 'Z'
                    dt = datetime.strptime(date_published, "%Y-%m-%dT%H:%M:%S.%fZ")
                    # Format to the desired format
                    formatted_datetime = dt.strftime("%Y-%m-%d %H:%M:%S")
                else:
                    dt = datetime.strptime(date_published, "%Y-%m-%dT%H:%M:%SZ")
                    # Format to the desired format
                    formatted_datetime = dt.strftime("%Y-%m-%d %H:%M:%S")
            elif "T" in date_published and "Z" not in date_published:
                # Parse the ISO 8601 format with microseconds and 'Z'
                dt = datetime.strptime(date_published, "%Y-%m-%dT%H:%M:%S")
                # Format to the desired format
                formatted_datetime = dt.strftime("%Y-%m-%d %H:%M:%S")
            else:
                try:
                    # If already in the correct format, simply return it
                    dt = datetime.strptime(date_published, "%Y-%m-%d %H:%M:%S")
                    formatted_datetime = dt.strftime("%Y-%m-%d %H:%M:%S")
                except ValueError:
                    # Handle cases where the format doesn't match expected patterns
                    raise ValueError("Unrecognized datetime format")
            converted_dates.append(formatted_datetime)

        df["date_published_converted"] = converted_dates

        try:
            df["date_published_converted"] = pd.to_datetime(
                df["date_published_converted"], errors="coerce"
            )

        except Exception as e:
            logger.error("An error occurred:", e)

        non_datetime_values = df[df["date_published_converted"].isna()]["date_published_converted"]

        if not non_datetime_values.empty:
            logger.error("The following rows could not be converted to datetime:")
            logger.error(df[df["date_published_converted"].isna()])

        # Step 3: Optionally, remove or handle rows with NaT values
        df = df.dropna(subset=["date_published_converted"])

        if not pd.api.types.is_datetime64_any_dtype(df["date_published_converted"]):
            logger.error("Error: 'date_published' is still not in datetime format after handling.")
        else:
            logger.info("Date_published successfully converted to datetime format.")

        for index, row in df.iterrows():
            if pd.isna(row["date_published_converted"]):  # Check if conversion resulted in NaT
                logger.error(
                    f"Row {index} with date_published value '{row['date_published']}' could not be converted."
                )
            if not isinstance(row["date_published_converted"], pd.Timestamp):
                logger.error(row)

        # df.to_csv("test.csv", index=False, escapechar="\\", quoting=csv.QUOTE_ALL)

        df["malware_type_final"] = np.where(
            (df["malware_type_x"].isna()) | (df["malware_type_x"] == "unknown"),
            df["predicted_malware_type"],
            df["malware_type_x"],
        )

        # Group by date and malware_type to count occurrences
        grouped_df = (
            df.groupby([df["date_published_converted"].dt.to_period("M"), "malware_type_final"])
            .size()
            .reset_index(name="count")
        )

        # Convert to timestamp for time series models
        grouped_df["date_published_converted"] = grouped_df[
            "date_published_converted"
        ].dt.to_timestamp()

        logger.info(grouped_df.head())

        # visualize data
        # Set the plot style
        sns.set_style("whitegrid")

        # Plot the number of CVEs over time for each malware type
        plt.figure(figsize=(14, 7))
        sns.lineplot(
            data=grouped_df, x="date_published_converted", y="count", hue="malware_type_final"
        )
        plt.title("Number of CVEs by Malware Type Over Time")
        plt.xlabel("Date Published")
        plt.ylabel("Count")
        plt.legend(title="Malware Type", bbox_to_anchor=(1.05, 1), loc="upper left")
        plt.xticks(rotation=45)
        plt.tight_layout()

        # Save the plot to an image file
        plt.savefig("./output/cve_by_malware_type.png", format="png", dpi=300, bbox_inches="tight")

        # plt.show()

        # Create a list to store models and future dataframes
        models = {}
        future_dfs = {}
        forecast_dfs = {}

        # Iterate over each malware type
        for malware in grouped_df["malware_type_final"].unique():
            # Prepare the data for Prophet
            df_malware = grouped_df[grouped_df["malware_type_final"] == malware]

            if (
                df_malware.shape[0] < 2
                or df_malware["count"].isna().sum() >= df_malware.shape[0] - 1
            ):
                logger.warning(f"Not enough data for {malware}. Skipping this malware type.")
            else:

                df_prophet = df_malware.rename(
                    columns={"date_published_converted": "ds", "count": "y"}
                )[["ds", "y"]]

                print(df_prophet)

                # Initialize and fit the model
                model = Prophet(
                    yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False
                )
                model.fit(df_prophet)

                # Store the model
                models[malware] = model

                # Create a future dataframe for forecasting
                future = model.make_future_dataframe(
                    periods=12, freq="M"
                )  # Forecast for 12 months into the future
                future_dfs[malware] = future

                # Make predictions
                forecast = model.predict(future)
                forecast_dfs[malware] = forecast

                # Plot forecast
                model.plot(forecast)
                plt.title(f"Forecast for {malware}")
                plt.xlabel("Date")
                plt.ylabel("Number of CVEs")
                plt.savefig(
                    f"./output/forecast_{malware}.png", format="png", dpi=300, bbox_inches="tight"
                )
                #   plt.show()

        # Evaluate each model
        for malware, forecast in forecast_dfs.items():
            # Filter the forecast to only include the actual dates
            actual = grouped_df[grouped_df["malware_type_final"] == malware]
            forecast_filtered = forecast.loc[
                forecast["ds"].isin(actual["date_published_converted"])
            ]

            # Calculate metrics
            mae = mean_absolute_error(actual["count"], forecast_filtered["yhat"])
            mse = mean_squared_error(actual["count"], forecast_filtered["yhat"])
            rmse = mse**0.5

            logger.info(f"{malware} - MAE: {mae:.2f}, MSE: {mse:.2f}, RMSE: {rmse:.2f}")

        # forecast and save to csv
        for malware, forecast in forecast_dfs.items():
            # Filter the forecast to only include the future dates
            future_forecast = forecast.loc[
                forecast["ds"] > grouped_df["date_published_converted"].max()
            ]

            # Save to CSV
            future_forecast.to_csv(f"./output/forecast_{malware}.csv", index=False)

            # data_dict = future_forecast.to_dict("records")
            # for cve in data_dict:
            #     self._output_repository.save(cve)

            print(f"Forecast for {malware} saved to forecast_{malware}.csv")
