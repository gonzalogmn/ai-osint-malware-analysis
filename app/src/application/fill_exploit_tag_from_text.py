import pandas as pd

from config.logger import logger
from src.model.cve_repository import CVERepository

EXPLOIT_TAGS = {
    "Authentication Bypass / Credentials Bypass (AB/CB)": [
        "authentication bypass",
        "credentials bypass",
        "ab/cb",
    ],
    "Buffer Overflow": ["buffer overflow"],
    "Bug Report": ["bug report"],
    "Client Side": ["client side"],
    "Code Injection": ["code injection"],
    "Command Injection": ["command injection"],
    "Console": ["console"],
    "Cross-Site Request Forgery (CSRF)": ["cross-site request", "csrf"],
    "Cross-Site Scripting (XSS)": ["cross-site script", "xss"],
    "Denial of Service (DoS)": ["denial of service", "dos"],
    "Deserialization": ["deserialization"],
    "File Inclusion (LFI/RFI)": ["file inclusion", "lfi", "rfi"],
    "Heap Overflow": ["heap overflow"],
    "Integer Overflow": ["integer overflow"],
    "Local": ["local"],
    "Malware": ["malware"],
    "Metasploit Framework (MSF)": ["metasploit", "msf"],
    "NULL Pointer Dereference": ["null pointer dereference"],
    "Object Injection": ["object injection"],
    "Out Of Bounds": ["out of bounds"],
    "Pwn2Own": ["pwn2own"],
    "Race Condition": ["race condition"],
    "Remote": ["remote"],
    "Server-Side Request Forgery (SSRF)": ["server-side request forgery", "ssrf"],
    "SQL Injection (SQLi)": ["sql injection", "sqli"],
    "Traversal": ["traversal"],
    "Type Confusion": ["type confusion"],
    "Use After Free (UAF)": ["use after free", "uaf"],
    "WordPress Plugin": ["wordpress plugin"],
    "WordPress Core": ["wordpress core", "wordpress"],
    "XML External Entity (XXE)": ["xml external entity", "xxe"],
}


class FillExploitTagFromText:
    def __init__(self, input_repository: CVERepository, output_repository: CVERepository):
        self._input_repository = input_repository
        self._output_repository = output_repository

    def _determine_exploit_tag(self, row):
        default_result = (
            row["exploit_tag"]
            if (
                "exploit_tag" in row
                and row["exploit_tag"] != ""
                and not pd.isna(row["exploit_tag"])
            )
            else "unknown"
        )
        if "exploit_description" not in row or pd.isna(row["exploit_description"]):
            return default_result

        exploit_description = row["exploit_description"].lower()
        description = row["description"].lower()
        text = description + " " + exploit_description

        for exploit_tag, keywords in EXPLOIT_TAGS.items():
            for keyword in keywords:
                if keyword in text:
                    return exploit_tag
        return default_result

    def __call__(self):
        logger.info("Starting FillExploitTagFromText use case...")
        cves = self._input_repository.find_all()

        df = pd.DataFrame(cves)

        df["exploit_tag_generated"] = df.apply(
            lambda row: (self._determine_exploit_tag(row)),
            axis=1,
        )

        data_dict = df.to_dict("records")
        data_len = len(data_dict)
        for index, cve in enumerate(data_dict):
            logger.info(f"Saving {index}/{data_len}")
            self._output_repository.update_exploit_tag_generated(cve)
